#!/bin/bash

###############################################################################################
##                                                                                           ##
##                       Universidad Carlos III de Madrid (UC3M)                             ##
##                                                                                           ##
##    Lightning - The simple and lightweight network simulator based on Docker containers    ##
##                                                                                           ##
##    author:         Pablo Toribio (under supervision of professor C.J. Bernardos Cano)     ##
##                                                                                           ##
##    project site:   https://github.com/ptoribi/lightning                                   ##
##                                                                                           ##
##    file description:  library that provides several functions to be included and used     ##
##                       by the main program                                                 ##
##                                                                                           ##
###############################################################################################

#echo "functions --> logname: $(logname)"
#echo "functions --> whoami:  $(whoami)"

function log_name() {
  [ -n "$SUDO_USER" ] && echo $SUDO_USER
  [ -z "$SUDO_USER" ] && id -un
}

# User-related variables
USER_BEHIND_SUDO=$(log_name)
GROUP_OF_USER_BEHIND_SUDO=$(id -g -n $USER_BEHIND_SUDO)
# ptoribi: getent also works with remote authentication servers (LDAP, etc.)
# from "getent passwd" output: user:x:1000:1000:user,,,:/home/user:/bin/bash -> I extract the 6th field delimited by ":" (user's home path)
USER_BEHIND_SUDO_HOME_PATH=$(getent passwd $USER_BEHIND_SUDO | cut -d : -f 6)

# System-related variables
# ptoribi: "which" will find in the path the full location of the executable, "readlink -f" will resolve all possible symbolic links and "dirname" will remove the last component (file name).
LIGHTNING_INSTALLATION_PATH=$(dirname $(readlink -f $(which lightning)))
source $LIGHTNING_INSTALLATION_PATH/variables.conf
SCENARIOS_PATH=$LIGHTNING_INSTALLATION_PATH/scenarios
SCENARIOS_PATH_LOCAL=$LIGHTNING_INSTALLATION_PATH/scenarios-local
XSD_FILE=$LIGHTNING_INSTALLATION_PATH/lightning-xml-schema.xsd
QUAGGA_CONFIG_FILES=$LIGHTNING_INSTALLATION_PATH/quagga-config-files
CONTAINERS_CREATED_FILE=$LOGS_LOCATION/containers-created.log
NETWORKS_CREATED_FILE=$LOGS_LOCATION/networks-created.log
LIGHTNING_GENERAL_LOG_FILE=$LOGS_LOCATION/lightning.log
SECURITY_CAPABILITIES_FILE=$LIGHTNING_INSTALLATION_PATH/security/container_capabilities.conf
SECURITY_SUDO_COMMANDS_FILE=$LIGHTNING_INSTALLATION_PATH/security/sudo_commands.conf

if [[ $SHARED_FOLDER_LOCATION == "TMP" ]]
then
  SHARED_FOLDER=/tmp/$USER_BEHIND_SUDO/$SHARED_FOLDER_NAME
else
  SHARED_FOLDER=$USER_BEHIND_SUDO_HOME_PATH/$SHARED_FOLDER_NAME
fi

# usage: version_header
# description: shows header displaying version number
version_header() {

  echo ""
  echo "      $(tput setaf 33)***************************************************$(tput sgr 0)"
  echo "      $(tput setaf 33)**$(tput setaf 45)    Universidad Carlos III de Madrid (UC3M)    $(tput setaf 33)**$(tput sgr 0)"
  echo "      $(tput setaf 33)**$(tput setaf 45)              Lightning $(cat $LIGHTNING_INSTALLATION_PATH/version)                  $(tput setaf 33)**$(tput sgr 0)"
  echo "      $(tput setaf 33)***************************************************$(tput sgr 0)"
}

#paaguti:
# usage: $(get_sysctl <container_type>)
# description: read the special sysctls from $LIGHTNING_INSTALLATION_PATH/sysctl.conf
# and generate the --sysctl <value> ... parameters

function get_sysctl() {
  DEFFILE=$LIGHTNING_INSTALLATION_PATH/sysctl-$1.conf

  [ -e $DEFFILE ] || echo "WARNING: $DEFFILE not found!"
  [ -e $DEFFILE ] || return

  while IFS= read -r -u13 line; do
    printf " --sysctl %s " "$line"
  done 13<"$DEFFILE"
}

# usage: explore_scenarios
# description: explore all the directories in $SCENARIOS_PATH_LOCAL and $SCENARIOS_PATH listing all the available scenarios
# NOTE: this function only supports one directory depth level from $SCENARIOS_PATH_LOCAL and $SCENARIOS_PATH
explore_scenarios() {

  local NUMBER_DIRECTORIES
  local DIRECTORY_NAME

  list_scenarios_in_directory $SCENARIOS_PATH_LOCAL

  NUMBER_DIRECTORIES=$(ls -l $SCENARIOS_PATH_LOCAL | awk 'NR>1' | grep ^d | awk '{print $9}' | wc -l)
  for ((i=1; i<=$NUMBER_DIRECTORIES; i++))
  do
    DIRECTORY_NAME=$(ls -l $SCENARIOS_PATH_LOCAL | awk 'NR>1' | grep ^d | awk '{print $9}' | sed -n $i'p')
    list_scenarios_in_directory $SCENARIOS_PATH_LOCAL $DIRECTORY_NAME
  done

  list_scenarios_in_directory $SCENARIOS_PATH

  NUMBER_DIRECTORIES=$(ls -l $SCENARIOS_PATH | awk 'NR>1' | grep ^d | awk '{print $9}' | wc -l)
  for ((i=1; i<=$NUMBER_DIRECTORIES; i++))
  do
    DIRECTORY_NAME=$(ls -l $SCENARIOS_PATH | awk 'NR>1' | grep ^d | awk '{print $9}' | sed -n $i'p')
    list_scenarios_in_directory $SCENARIOS_PATH $DIRECTORY_NAME
  done
}

# usage: list_scenarios_in_directory PATH [DIRECTORY]
# description: list the available scenarios in the specified path or path+directory (XML or direct execution scenario files)
# example: list_scenarios_in_directory /usr/local/lightning/scenarios RYSCA
list_scenarios_in_directory() {

  local DIRECTORY=$1/$2

  local NUMBER_SCENARIOS_FILES
  local FILE_NAME           # name of the file, e.g.: scenario.xml
  local FILE_NAME_EXTENDED  # name of the file + relative path from $SCENARIOS_PATH, e.g.: SubjectName/LaboratorySession_1/scenario.xml
  local DESCRIPTION

  NUMBER_SCENARIOS_FILES=$(ls -l $DIRECTORY | awk 'NR>1' | grep -v ^d | awk '{print $9}' | grep -v .xsd | grep -v .pdf | grep -v .tmp | wc -l)
  if [[ $NUMBER_SCENARIOS_FILES -gt 0 ]]
  then
    echo "" # ptoribi: separator line between scenarios of different directory
  fi

  for ((j=1; j<=$NUMBER_SCENARIOS_FILES; j++))
  do
    FILE_NAME=$(ls -l $DIRECTORY | awk 'NR>1' | grep -v ^d | awk '{print $9}' | grep -v .xsd | grep -v .pdf | grep -v .tmp | sed -n $j'p')

    # ptoribi: if the file is an XML file
    if [[ $FILE_NAME == *.xml ]]
    then
      DESCRIPTION=$(xmllint --xpath 'string(/scenario/@description)' $DIRECTORY/$FILE_NAME)
    fi

    # ptoribi: if the file is a direct execution file (file without extension)
    if [[ $FILE_NAME != *.* ]]
    then
      # ptoribi: I use awk for taking all that is after "# DESCRIPTION:", and tail for removing the following space
      DESCRIPTION=$(grep "# DESCRIPTION:" $DIRECTORY/$FILE_NAME | awk -F '# DESCRIPTION:' '{print $2}' | tail -c +2)
      if [[ ${#DESCRIPTION} -eq 0 ]]
      then
        DESCRIPTION="[scenario description not available]"
      fi
    fi

    if [ "$#" -eq 2 ]
    then
      echo "  $(tput setaf 154) $2/${FILE_NAME%.*}$(tput sgr 0) - $(tput setaf 244)$DESCRIPTION $(tput sgr 0)"
    else
      echo "  $(tput setaf 154) ${FILE_NAME%.*}$(tput sgr 0) - $(tput setaf 244)$DESCRIPTION $(tput sgr 0)"
    fi
  done
}

# usage: usage_message
# description: shows usage message of the program and available scenarios
usage_message() {
  echo ""
  echo "$(tput setaf 220)[lightning]$(tput sgr 0) usage:"
  echo ""
  echo "  $(tput setaf 6)lightning [-h]             $(tput sgr 0)-> display usage message and list available scenarios"
  echo "  $(tput setaf 6)lightning stop             $(tput sgr 0)-> close running scenario"
  echo "  $(tput setaf 6)lightning purge            $(tput sgr 0)-> ONLY use this option in case \"stop\" doesn't work"
  echo "  $(tput setaf 6)lightning start [flags]    $(tput setaf 154)$(tput smul)SCENARIO$(tput rmul)   $(tput sgr 0)-> start selected network scenario"
  echo "  $(tput setaf 196)lightning update           $(tput sgr 0)-> update Lightning to the latest version available"
  echo ""
  echo "  flags:"
  echo "    $(tput setaf 6)-R 0         $(tput sgr 0) set REMOTE to 0 for future sessions and start in local mode"
  echo "    $(tput setaf 6)-R 1         $(tput sgr 0) set REMOTE to 1 for future sessions and start in accesible mode"
  echo "  Available scenarios:"
  #list_scenarios_in_directory $SCENARIOS_PATH
  explore_scenarios
  echo ""
  echo "  Your shared folder between host systems is located"
  echo "  at $(tput setaf 13)$SHARED_FOLDER$(tput sgr 0) in your main system, and will"
  echo "  be mounted as $(tput setaf 5)/home/$USER_BEHIND_SUDO$(tput sgr 0) inside the simulated host systems."
  echo ""

  if [[ $SHARED_FOLDER_LOCATION == "TMP" ]]
  then
    echo "  $(tput setaf 196)WARNING!!$(tput sgr 0) the /tmp folder is wiped every time the Linux OS is restarted: please"
    echo "  backup the content of $(tput setaf 13)$SHARED_FOLDER$(tput sgr 0) in your home folder"
    echo "  after using lightning if you don't want to lose all your files."
    echo ""
  fi
}


# description: disables ipv6 for one interface in the specified container (container should have been started in "privileged" mode)
# usage: disable_ipv6 CONTAINER_NAME INTERFACE_NAME
# example: disable_ipv6 pc1 eth1
disable_ipv6() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  # ptoribi: with sysctl dots should not be used as some eth interfaces contain a dot in their name (e.g. eth0.0), use slashes instead
  ip netns exec $CONTAINER_NAME sysctl -w net/ipv6/conf/$INTERFACE_NAME/disable_ipv6=1 > /dev/null
}

# description: enables ipv4 reverse path for one interface in the specified container (container should have been started in "privileged" mode)
# usage:   set_rp_filter CONTAINER_NAME INTERFACE_NAME 0/1
# example: set_rp_filter pc1 eth1 1
set_rp_filter() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local RP_FILTER=$3

  # ptoribi: with sysctl dots should not be used as some eth interfaces contain a dot in their name (e.g. eth0.0), use slashes instead
  ip netns exec $CONTAINER_NAME sysctl -w net/ipv4/conf/$INTERFACE_NAME/rp_filter=$RP_FILTER > /dev/null
}

# description: enables ipv4 reverse path filtering for one interface in the specified container (container should have been started in "privileged" mode)
# usage:   enable_rp_filter CONTAINER_NAME INTERFACE_NAME
# example: enable_rp_filter pc1 eth1
enable_rp_filter() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  # ptoribi: with sysctl dots should not be used as some eth interfaces contain a dot in their name (e.g. eth0.0), use slashes instead
  ip netns exec $CONTAINER_NAME sysctl -w net/ipv4/conf/$INTERFACE_NAME/rp_filter=1 > /dev/null
}

# description: disables ipv4 reverse path filtering for one interface in the specified container (container should have been started in "privileged" mode)
# usage:   disable_rp_filter CONTAINER_NAME INTERFACE_NAME
# example: disable_rp_filter pc1 eth1
disable_rp_filter() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  # ptoribi: with sysctl dots should not be used as some eth interfaces contain a dot in their name (e.g. eth0.0), use slashes instead
  ip netns exec $CONTAINER_NAME sysctl -w net/ipv4/conf/$INTERFACE_NAME/rp_filter=0 > /dev/null
}


# description: clears all IP addresses present in the selected interface
# usage: clear_interface CONTAINER_NAME INTERFACE_NAME
# example: clear_interface pc1 eth1
clear_interface() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  docker exec --user=root $CONTAINER_NAME ip addr flush dev $INTERFACE_NAME
}


# description: creates a L2 network segment
# usage: create_network NET_NAME TYPE (max. NET_NAME length 15-3=12 characters)
# example: create_network net1 switch
create_network() {

  local NET_NAME=$1
  local TYPE=$2

  #if [[ -z $(ls -l /sys/class/net/ | awk 'NR>1' | awk '{print $9}' | grep -x $NET_NAME"_br") ]]
  # ptoribi: if the network doesn't exist yet, it will be created
  if [[ -z $(ls /sys/class/net/ | grep -x $NET_NAME"_br") ]]
  then
    local BRIDGE_NAME=$NET_NAME"_br"

    brctl addbr $BRIDGE_NAME
    ip link set dev $BRIDGE_NAME up

    # ptoribi: now FORWARD rule has to be allowed in iptables for that bridge
    iptables -A FORWARD -i $BRIDGE_NAME -j ACCEPT

    # ptoribi: add created network to NETWORKS_CREATED_FILE (it actually adds the bridge name)
    echo $BRIDGE_NAME >> $NETWORKS_CREATED_FILE

    information_message "Network segment $NET_NAME successfully created"
  else
    error_message "Network segment $NET_NAME already exists"
  fi

  if [ $TYPE == "hub" ]
  then
    brctl setageing $BRIDGE_NAME 0
  fi
}


# usage: create_container CONTAINER_NAME CONTAINER_NAME_LONG TYPE
# description: creates a host/router with no network interfaces
# example: create_container h1 host1 host
create_container() {

  local CONTAINER_NAME=$1
  local CONTAINER_NAME_LONG=$2
  local TYPE=$3
  local XML_FILE_WITHOUT_EXTENSION=$(echo $4 | rev | cut --complement -d "." -f 1 | rev) # e.g. from /usr/local/lightning/scenarios/RYSCA/simple_con_router.xml to /usr/local/lightning/scenarios/RYSCA/simple_con_router

  if [ $TYPE == "host" ]
  then
    create_host $CONTAINER_NAME $CONTAINER_NAME_LONG $XML_FILE_WITHOUT_EXTENSION
  fi

  if [ $TYPE == "router" ]
  then
    create_router $CONTAINER_NAME $CONTAINER_NAME_LONG $XML_FILE_WITHOUT_EXTENSION
  fi
}


# usage: create_host HOST_NAME HOST_NAME_LONG XML_FILE_WITHOUT_EXTENSION
# description: creates a host with no network interfaces
# example create_host h1 host1 /usr/local/lightning/scenarios/RYSCA/simple_con_router
create_host() {

  local HOST_NAME=$1
  local HOST_NAME_LONG=$2

  local line_number
  local READEN_LINE
  local CAPABILITY
  local SUDO_COMMAND
  local first_command_readen=0
  # ptoribi: this variable will have the form "--cap-add=CAP1 --cap-add=CAP2 --cap-add=CAP3 ..."
  local CAP_ADD_CHAIN_LIST
  # ptoribi: this variable will have the form "/route/to/command_1, /route/to/command_2, ..."
  local SUDO_COMMANDS_CHAIN_LIST

  # ptoribi: populate CAP_ADD_CHAIN_LIST variable with the uncommented capabilities of the file SECURITY_CAPABILITIES_FILE
  line_number=1
  if [ -e $SECURITY_CAPABILITIES_FILE ]
  then
    while :
    do
      # ptoribi: I read the nth line of the file
      READEN_LINE=$(sed -n ${line_number}p $SECURITY_CAPABILITIES_FILE)
      if [ -z "$READEN_LINE" ]
      then
        break
      else
        if [[ $(echo $READEN_LINE | grep -v ^\#) > 0 ]]
        then
          # ptoribi: line does not start by #, so it is a line containing a capability
          # I take the first word of the line, which is actually the capability
          CAPABILITY=$(echo $READEN_LINE | awk '{print $1}')
          CAP_ADD_CHAIN_LIST=$CAP_ADD_CHAIN_LIST"--cap-add="$CAPABILITY" "
          #echo "Capability:" $CAPABILITY
        fi
        # ptoribi: in bash we use $((...)) for arithmetic expressions
        # line_number is increased in 1
        line_number=$((line_number+1))
      fi
    done
  else
    error_message "$SECURITY_CAPABILITIES_FILE not found!"
  fi

  # ptoribi: populate SUDO_COMMANDS_CHAIN_LIST variable with the uncommented capabilities of the file SECURITY_SUDO_COMMANDS_FILE
  line_number=1
  if [ -e $SECURITY_SUDO_COMMANDS_FILE ]
  then
    while :
    do
      # ptoribi: I read the nth line of the file
      READEN_LINE=$(sed -n ${line_number}p $SECURITY_SUDO_COMMANDS_FILE)
      if [ -z "$READEN_LINE" ]
      then
        break
      else
        if [[ $(echo $READEN_LINE | grep -v ^\#) > 0 ]]
        then
          # ptoribi: line does not start by #, so it is a line containing a capability
          # I take the first word of the line, which is actually the command
          SUDO_COMMAND=$(echo $READEN_LINE | awk '{print $1}')
          if [[ first_command_readen -eq 0 ]]
          then
            # ptoribi: if it is the first command of the list
            SUDO_COMMANDS_CHAIN_LIST=$SUDO_COMMAND
            first_command_readen=1
          else
            # ptoribi: if it is the n>1 command of the list
            SUDO_COMMANDS_CHAIN_LIST=$SUDO_COMMANDS_CHAIN_LIST", "$SUDO_COMMAND
          fi
          #echo "Sudo Command:" $SUDO_COMMAND
        fi
        # ptoribi: in bash we use $((...)) for arithmetic expressions
        # line_number is increased in 1
        line_number=$((line_number+1))
      fi
    done
  else
    error_message "$SECURITY_SUDO_COMMANDS_FILE not found!"
  fi

  #echo USER_BEHIND_SUDO: $USER_BEHIND_SUDO
  #runuser -l $USER_BEHIND_SUDO -c 'mkdir -p $HOME/$SHARED_FOLDER'
  #su -l $USER_BEHIND_SUDO -c "mkdir -p $HOME/$SHARED_FOLDER"
  # sudo -u $USER_BEHIND_SUDO mkdir -p $HOME/$SHARED_FOLDER
  #mkdir -p $SHARED_FOLDER
  #chown $USER_BEHIND_SUDO:$GROUP_OF_USER_BEHIND_SUDO $SHARED_FOLDER

  # ptoribi: run container with X-org forwarding support (I will try to make the same stuff but with wayland later) and $SHARED_FOLDER mounted as the home of the container
  # --rm means the container will be destroyed when stopped, no need to make "docker rm $HOST_NAME" after stop
  # with "--cap-drop=ALL" I will drop all capabilities in order to have full control by adding one by one
  # the capabilities present in the file SECURITY_SUDO_COMMANDS_FILE will the only ones added to the containers
  # --sysctl net.ipv6.conf.all.disable_ipv6=0 enables IPv6
  # --sysctl net.ipv4.conf.all.rp_filter=0 disables reverse path filtering (and allows asymmetric routing)
  docker run -t -d --rm --name=$HOST_NAME --hostname=$HOST_NAME_LONG --net=none $(get_sysctl host) \
         -e DISPLAY=unix$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix -v $SHARED_FOLDER:/home/$USER_BEHIND_SUDO --cap-drop=ALL \
         $CAP_ADD_CHAIN_LIST $DOCKER_IMAGE_host >> $LIGHTNING_GENERAL_LOG_FILE

  # ptoribi: create user inside the container with same uid:gid as the one executing this program
  docker exec --user=root $HOST_NAME groupadd --gid $(id -g $GROUP_OF_USER_BEHIND_SUDO) $GROUP_OF_USER_BEHIND_SUDO
  docker exec --user=root $HOST_NAME useradd --uid $(id -u $USER_BEHIND_SUDO) --gid $(id -g $GROUP_OF_USER_BEHIND_SUDO) $USER_BEHIND_SUDO

  # ptoribi: add the user to group "wireshark" so dumpcap could be executed by regular users
  docker exec --user=root $HOST_NAME usermod -a -G wireshark $USER_BEHIND_SUDO
  #docker cp $LIGHTNING_INSTALLATION_PATH/other/bash_persistent $HOST_NAME:/bin
  docker exec --user=root $HOST_NAME bash -c "echo \#Added by Lightning: >> /etc/hosts"
  docker exec --user=root $HOST_NAME bash -c "echo 127.0.1.1 $HOST_NAME_LONG >> /etc/hosts"
  # ptoribi: allow that user to execute sudo without writting the password each time
  docker exec --user=root $HOST_NAME bash -c "echo \#Added by Lightning: >> /etc/sudoers"
  docker exec --user=root $HOST_NAME bash -c "echo $USER_BEHIND_SUDO ALL=\(ALL\) NOPASSWD: $SUDO_COMMANDS_CHAIN_LIST >> /etc/sudoers"

  # ptoribi: create links for accessing the network namespace
  local CONTAINER_PID=`docker inspect -f '{{.State.Pid}}' $HOST_NAME`
  mkdir -p /var/run/netns
  ln -sf /proc/1/ns/net /var/run/netns/default
  ln -sf /proc/$CONTAINER_PID/ns/net /var/run/netns/$HOST_NAME

  # ptoribi: add created container to CONTAINERS_CREATED_FILE
  echo $HOST_NAME >> $CONTAINERS_CREATED_FILE

  information_message "Container $HOST_NAME (PID=$CONTAINER_PID) successfully created"
}


# usage: create_router ROUTER_NAME ROUTER_NAME_LONG XML_FILE_WITHOUT_EXTENSION
# description: creates a router with no network interfaces
# example: create_router r1 router1 /usr/local/lightning/scenarios/RYSCA/simple_con_router
create_router() {

  local ROUTER_NAME=$1
  local ROUTER_NAME_LONG=$2
  local XML_FILE_WITHOUT_EXTENSION=$3
  local PATH_TO_CONTAINER_SPECIFIC_CONFIG_FILES=$3"-config_files"/$ROUTER_NAME

  local line_number
  local READEN_LINE
  local CAPABILITY
  # ptoribi: this variable will have the form "--cap-add=CAP1 --cap-add=CAP2 --cap-add=CAP3 ..."
  local CAP_ADD_CHAIN_LIST

  # ptoribi: populate CAP_ADD_CHAIN_LIST variable with the uncommented capabilities of the file SECURITY_CAPABILITIES_FILE
  line_number=1
  if [ -e $SECURITY_CAPABILITIES_FILE ]
  then
    while :
    do
      # ptoribi: I read the nth line of the file
      READEN_LINE=$(sed -n ${line_number}p $SECURITY_CAPABILITIES_FILE)
      if [ -z "$READEN_LINE" ]
      then
        break
      else
        if [[ $(echo $READEN_LINE | grep -v ^\#) > 0 ]]
        then
          # ptoribi: line does not start by #, so it is a line containing a capability
          # I take the first word of the line, which is actually the capability
          CAPABILITY=$(echo $READEN_LINE | awk '{print $1}')
          CAP_ADD_CHAIN_LIST=$CAP_ADD_CHAIN_LIST"--cap-add="$CAPABILITY" "
          #echo "Capability:" $CAPABILITY
        fi
        # ptoribi: in bash we use $((...)) for arithmetic expressions
        # line_number is increased in 1
        line_number=$((line_number+1))
      fi
    done
  else
    error_message "$SECURITY_CAPABILITIES_FILE not found!"
  fi

  # ptoribi: run container
  # --rm means the container will be destroyed when stopped, no need to make "docker rm $ROUTER_NAME" after stop
  # with "--cap-drop=ALL" I will drop all capabilities in order to have full control by adding one by one
  # the capabilities present in the file SECURITY_SUDO_COMMANDS_FILE will the only ones added to the containers
  # --sysctl net.ipv6.conf.all.disable_ipv6=0 enables IPv6
  # --sysctl net.ipv6.conf.all.forwarding=1 enables IPv6 forwarding
  # --sysctl net.ipv4.conf.all.rp_filter=0 disables reverse path filtering (and allows asymmetric routing)
  docker run -t -d --rm --name=$ROUTER_NAME --hostname=$ROUTER_NAME_LONG --net=none $(get_sysctl router) \
         --cap-drop=ALL $CAP_ADD_CHAIN_LIST $DOCKER_IMAGE_router >> $LIGHTNING_GENERAL_LOG_FILE

  # ptoribi: create links for accessing the network namespace
  local CONTAINER_PID=`docker inspect -f '{{.State.Pid}}' $ROUTER_NAME`
  mkdir -p /var/run/netns
  ln -sf /proc/1/ns/net /var/run/netns/default
  ln -sf /proc/$CONTAINER_PID/ns/net /var/run/netns/$ROUTER_NAME

  # ptoribi: copy quagga configuration files to the router container
  if [ -d "$PATH_TO_CONTAINER_SPECIFIC_CONFIG_FILES/quagga" ]; then
    # ptoribi: the common quagga configuration files will be copied to the router container and stored in /etc/quagga
    docker cp $QUAGGA_CONFIG_FILES/quagga $ROUTER_NAME:/etc
    # ptoribi: if directory for storing specific config files for this container "SCENARIO_NAME-config_files/quagga" exists, these files will be copied to /etc/quagga and will overwrite the common quagga configuration files
    docker cp $PATH_TO_CONTAINER_SPECIFIC_CONFIG_FILES/quagga $ROUTER_NAME:/etc
  else
    # ptoribi: the common quagga configuration files will be copied to the router container and stored in /etc/quagga
    docker cp $QUAGGA_CONFIG_FILES/quagga $ROUTER_NAME:/etc
  fi

  #docker cp $LIGHTNING_INSTALLATION_PATH/other/vtysh_persistent $ROUTER_NAME:/usr/bin
  # ptoribi: all the config files must be owned by user and group "quagga" in order to work
  docker exec --user=root $ROUTER_NAME bash -c "chown -R quagga:quagga /etc/quagga"
  # ptoribi: the vtysh config file must be owned by user "quagga" and group "quaggavty" in order to work
  docker exec --user=root $ROUTER_NAME bash -c "chown quagga:quaggavty /etc/quagga/vtysh.conf"
  # ptoribi: the default hostname in the quagga configuration files will be replaced by the one specified for this router
  docker exec --user=root $ROUTER_NAME bash -c "sed -i "s/DEFAULT_HOSTNAME/$ROUTER_NAME_LONG/g" /etc/quagga/*"

  # ptoribi: add created container to CONTAINERS_CREATED_FILE
  echo $ROUTER_NAME >> $CONTAINERS_CREATED_FILE

  information_message "Container $ROUTER_NAME (PID=$CONTAINER_PID) successfully created"
}


# usage: create_interface CONTAINER_NAME INTERFACE_NAME [IP/SM]
# description: creates an ethernet interface in the specified container, optionally also configures an IP address
# example: create_interface h1 eth0 192.168.0.1/24
create_interface() {

  ### CREATE INTERFACE & PAIRS FOR THAT CONTAINER ###
  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  local INTERFACE_NAME_TO_BRIDGE=$CONTAINER_NAME"_"$INTERFACE_NAME
  ip netns exec $CONTAINER_NAME ip link add $INTERFACE_NAME type veth peer name $INTERFACE_NAME_TO_BRIDGE
  ip netns exec $CONTAINER_NAME ip link set $INTERFACE_NAME_TO_BRIDGE netns default
  ip netns exec $CONTAINER_NAME ip link set dev $INTERFACE_NAME up
  ip link set dev $INTERFACE_NAME_TO_BRIDGE up

  if [ "$#" -eq 3 ]; then
    # Assign IP to interface
    local IP_SM=$3
    configure_ip $CONTAINER_NAME $INTERFACE_NAME $IP_SM
  fi

  # Now both internal container interface and external are created, but not connected to any bridge
}

# usage: connect_machine CONTAINER_NAME INTERFACE_NAME NET_NAME [IP/SM]
# description: connects the specified interface to a network, optionally also configures an IP address
# requirements: the host and the net had to be already created
# example: connect_machine h1 eth0 net1 192.168.0.1/24
connect_machine() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local NET_NAME=$3

  # NOTE: CONTAINER CONNECTS TO BRIDGE
  local BRIDGE_NAME=$NET_NAME"_br"
  local INTERFACE_NAME_TO_BRIDGE=$CONTAINER_NAME"_"$INTERFACE_NAME
  brctl addif $BRIDGE_NAME $INTERFACE_NAME_TO_BRIDGE
  ip link set dev $INTERFACE_NAME_TO_BRIDGE up

  if [ "$#" -eq 4 ]; then
    # Assign IP to interface
    local IP_SM=$4
    configure_ip $CONTAINER_NAME $INTERFACE_NAME $IP_SM
  fi

  information_message "Container $CONTAINER_NAME ($INTERFACE_NAME) successfully connected to $NET_NAME"
}


# usage: connect_machine_physical CONTAINER_NAME INTERFACE_NAME PHYSICAL_INTERFACE [IP/SM]
# description: connects the specified interface to a physical network interface of the host machine,
# there is no need to previously create an interface inside the container, this function will do it.
# using macvlan, optionally also configures an IP address
# example: connect_machine_physical r1 eth0.0 eth0 192.168.0.1/24
connect_machine_physical() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local PHYSICAL_INTERFACE=$3

  # Check if PHYSICAL_INTERFACE is a physical NIC in the host system
  if [ -n $(ls -l /sys/class/net/ | awk 'NR>1' | grep -v virtual | awk '{print $9}' | grep -x $PHYSICAL_INTERFACE) ]
  then
    # NOTE: MACVLAN BRIDGE IS CREATED ON PHYSICAL INTERFACE
    # ptoribi: I use a temporal name for that macvlan interface *_tmp, so in case that it exist a physical network interface with the same  name in the host, it won't generate any problem

    ip link add $INTERFACE_NAME"_tmp" link $PHYSICAL_INTERFACE type macvlan mode bridge
    ip link set $INTERFACE_NAME"_tmp" netns $CONTAINER_NAME
    ip netns exec $CONTAINER_NAME ip link set $INTERFACE_NAME"_tmp" name $INTERFACE_NAME
    ip netns exec $CONTAINER_NAME ip link set dev $INTERFACE_NAME up

    if [ "$#" -eq 4 ]; then
      # Assign IP to interface
      local IP_SM=$4
      configure_ip $CONTAINER_NAME $INTERFACE_NAME $IP_SM
    fi
  else
    error_message "$PHYSICAL_INTERFACE is not a physical network interface of the host system"
  fi

  information_message "Container $CONTAINER_NAME ($INTERFACE_NAME) directly connected to physical interface $PHYSICAL_INTERFACE"
}


# NOTE: FUNCIÓN NO PROBADA !!!
# usage: disconnect_machine HOST_NAME INTERFACE_NAME NET_NAME
# description: disconnects the specified interface of a host from a network
# requirements: the net of that host had to be already connected to that network
# example: disconnect_machine h1 eth0 net1
disconnect_machine() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local NET_NAME=$3
  local CONTAINER_PID=`docker inspect -f '{{.State.Pid}}' $CONTAINER_NAME`

  local BRIDGE_NAME=$NET_NAME"_br"
  local INTERFACE_NAME_TO_BRIDGE=$CONTAINER_NAME"_"$INTERFACE_NAME
  ip link set dev $INTERFACE_NAME_TO_BRIDGE down
  brctl delif $BRIDGE_NAME $INTERFACE_NAME_TO_BRIDGE

  information_message "Container $CONTAINER_NAME ($INTERFACE_NAME) successfully disconnected from $NET_NAME"
}


# usage: configure_ip CONTAINER_NAME INTERFACE_NAME IP/SM
# description: adds IPv4 or IPv6 adress to the desired interface
# example: configure_ip hostA eth1 192.168.0.1/24
# example: configure_ip hostA eth1 2001:0db8:0:f101::1/64
configure_ip() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local IP_SM=$3

  if [[ $IP_SM == *"."*"."*"."* ]]
  then
    # ptoribi: it is a IPv4 address
    ip netns exec $CONTAINER_NAME ip addr add $IP_SM dev $INTERFACE_NAME
  else
    # ptoribi: it is a IPv6 address
    ip netns exec $CONTAINER_NAME ip -6 addr add $IP_SM dev $INTERFACE_NAME
  fi
}


# usage: display_host HOST_NAME [XTERM_WINDOW_TITLE]
# description: starts some services and launchs a xterm window running a previously created host
# example: display_host h1 host1
display_host() {

  local HOST_NAME=$1

  if [ "$#" -eq 2 ]
  then
    local XTERM_WINDOW_TITLE=$2
  else
    local XTERM_WINDOW_TITLE=$1
  fi

  # ptoribi: start ssh and telnet service in order to allow incoming connections
  docker exec --user=root $HOST_NAME bash -c "/etc/init.d/ssh start" >> $LIGHTNING_GENERAL_LOG_FILE
  docker exec --user=root $HOST_NAME bash -c "/etc/init.d/xinetd start" >> $LIGHTNING_GENERAL_LOG_FILE

  #xterm -T "$XTERM_WINDOW_TITLE" -e "docker exec -i -t --user=$USER_BEHIND_SUDO $HOST_NAME bash_persistent $USER_BEHIND_SUDO" &
  # paaguti: if REMOTE=1, just print the Docker commands for an external program
  if [ $REMOTE -ne 1 ]
  then
    mate-terminal --hide-menubar --title="$XTERM_WINDOW_TITLE" --command "docker exec -i -t --user=$USER_BEHIND_SUDO $HOST_NAME bash_persistent $USER_BEHIND_SUDO" &
  else
    echo "docker exec -i -t --user=$USER_BEHIND_SUDO $HOST_NAME bash_persistent $USER_BEHIND_SUDO" | tee -a $USER_BEHIND_SUDO_HOME_PATH/commands
  fi
}


# usage: display_router ROUTER_NAME [XTERM_WINDOW_TITLE]
# description: starts some services and launchs a xterm window running a previously created router
# example: display_router r1 router1
display_router() {

  local ROUTER_NAME=$1

  if [ "$#" -eq 2 ]
  then
    local XTERM_WINDOW_TITLE=$2
  else
    local XTERM_WINDOW_TITLE=$1
  fi

  # ptoribi: start ssh and telnet service in order to allow incoming connections
  docker exec --user=root $ROUTER_NAME bash -c "/etc/init.d/ssh start" >> $LIGHTNING_GENERAL_LOG_FILE
  docker exec --user=root $ROUTER_NAME bash -c "/etc/init.d/xinetd start" >> $LIGHTNING_GENERAL_LOG_FILE
  # ptoribi: the quagga daemon is started
  docker exec --user=root $ROUTER_NAME bash -c "/etc/init.d/quagga start" >> $LIGHTNING_GENERAL_LOG_FILE

  #xterm -T "$XTERM_WINDOW_TITLE" -e "docker exec -i -t $ROUTER_NAME vtysh_persistent" &
  # paaguti: if REMOTE=1, just print the Docker commands for an external program
  if [ $REMOTE -ne 1 ]
  then
    mate-terminal --hide-menubar --title="$XTERM_WINDOW_TITLE" --command "docker exec -i -t $ROUTER_NAME vtysh_persistent" &
  else
    echo "docker exec -i -t $ROUTER_NAME vtysh_persistent" | tee -a $USER_BEHIND_SUDO_HOME_PATH/commands
  fi
}


# usage: stop_containers
# description: reads from the log file where the name of started container are recorded and stops them one by one
# example: stop_containers
stop_containers() {

  if [ -e $CONTAINERS_CREATED_FILE ]
  then
    while :
    do
      local READEN_LINE=$(head -n 1 $CONTAINERS_CREATED_FILE)
      if [ -z "$READEN_LINE" ]
      then
        rm $CONTAINERS_CREATED_FILE
        if [ $? == 0 ]
        then
          success_message "Containers stopped!"
        fi
        break
      else
        docker stop $READEN_LINE >> $LIGHTNING_GENERAL_LOG_FILE
        if [ $? == 0 ]
        then
          information_message "Container $READEN_LINE successfully stopped"
        fi
        sed -i '1d' $CONTAINERS_CREATED_FILE
      fi
    done
  else
    error_message "$CONTAINERS_CREATED_FILE not found!"
  fi
}

# usage: delete_networks
# description: reads from the log file where the name of created networks are recorded and deletes them one by one
# example: delete_networks
delete_networks() {

  if [ -e $NETWORKS_CREATED_FILE ]
  then
    while :
    do
      local READEN_LINE=$(head -n 1 $NETWORKS_CREATED_FILE)
      if [ -z "$READEN_LINE" ]
      then
        rm $NETWORKS_CREATED_FILE
        if [ $? == 0 ]
        then
          success_message "Networks destroyed!"
        fi
        break
      else
        ip link set $READEN_LINE down
        if [ $? == 0 ]
        then
          brctl delbr $READEN_LINE
          if [ $? == 0 ]
          then
            information_message "Bridge $READEN_LINE successfully deleted"
          else
            error_message "Error when deleting bridge $READEN_LINE"
          fi
        else
          error_message "Error when setting down bridge $READEN_LINE"
        fi
        sed -i '1d' $NETWORKS_CREATED_FILE
      fi
    done
  else
    error_message "$NETWORKS_CREATED_FILE not found!"
  fi
}


# usage: error_message MESSAGE
# description: displays the specified text in black with red background
error_message() {
  echo $(tput setaf 220)[lightning]:$(tput sgr 0) $(tput setaf 0)$(tput setab 1) $1 $(tput sgr 0)
}

# usage: information_message MESSAGE
# description: displays the specified text in green
information_message() {
  echo $(tput setaf 220)[lightning]:$(tput sgr 0) $(tput setaf 2) $1 $(tput sgr 0)
}

# usage: success_message MESSAGE
# description: displays the specified text in black with green background
success_message() {
  echo $(tput setaf 220)[lightning]:$(tput sgr 0) $(tput setaf 0)$(tput setab 2) $1 $(tput sgr 0)
}

kill_evince() {
  [ $REMOTE -eq 1 ] && return
  EVINCE_PID=$(ps -ef | awk '/evince.*lightning/{ if ($9 ~ "local/lightning") print $2;}')
  if [ -z "$EVINCE_PID" ]; then
    error_message "No scenario picture"
  else
    kill $EVINCE_PID 2> /dev/null
    wait $EVINCE_PID 2> /dev/null
    success_message "Closed scenario picture"
  fi
}

# usage: lightning_stop
# description: executes stop_containers and delete_networks and sfter that deletes both log files
# example: lightning_stop
lightning_stop() {
  if [ -e $CONTAINERS_CREATED_FILE ] && [ -e $NETWORKS_CREATED_FILE ]
  then
    stop_containers
    delete_networks
    kill_evince
    success_message "Scenario successfully stopped"
  elif [ -e $CONTAINERS_CREATED_FILE ]
  then
    stop_containers
    kill_evince
    success_message "Scenario successfully stopped"
  elif [ -e $NETWORKS_CREATED_FILE ]
  then
    delete_networks
    kill_evince
    success_message "Scenario successfully stopped"
  else
    error_message "There is currently no scenario running to be stopped"
  fi
}


# usage: lightning_purge
# description: use with caution!, stops all the containers running in the host system and deletes
# all bridges whose name ends with "_br"
# example: lightning_purge
lightning_purge() {

  # ptoribi: stop all Docker container running on this system (and what if other containers not related to lightning are also running?, we do not care about the rest of this world)
  if [ -n "$(docker container ls -a -q)" ]
  then
    docker stop $(docker container ls -a -q) >> $LIGHTNING_GENERAL_LOG_FILE
  fi

  # ptoribi: set down and destroy all bridges whose name ends with "_br" (this is the bridge name convention used by lightning)
  while :
  do
    # ptoribi: next line is based on jil's response (https://stackoverflow.com/questions/36960003/how-to-extract-bridge-name-from-brctl-output-with-bash). Thanks jil!
    # Explanation:
    # NOTE: "record" is the same as "line" in the awk man entry
    # {print $1} will print only the first field of each line
    # NR>1 will remove the first line of the "brctl show" output, that is a header (not interesting for us as it hasn't info)
    # NF>1 will print only records that have more that one field (when one bridge has multiple interfaces attached, each one appear in one separated line, we do not care about interfaces, only about bridge names)
    NEXT_BRIDGE=$(brctl show | awk 'NF>1 && NR>1 {print $1}' | grep _br | head -n 1)
    if [ -z "$NEXT_BRIDGE" ]
    then
      break
    else
      ip link set $NEXT_BRIDGE down
      brctl delbr $NEXT_BRIDGE
    fi
  done

  # ptoribi: remove CONTAINERS_CREATED_FILE and NETWORKS_CREATED_FILE files
  rm -f $CONTAINERS_CREATED_FILE
  rm -f $NETWORKS_CREATED_FILE

  success_message "System successfully purged"
}


# usage: read_xml XML_FILE
# description: reads an XML scenario file and creates containers, networks and connections accordingly
# example: read_xml /usr/local/lightning/scenarios/RYSCA/simple_con_router.xml ->
read_xml() {

  local XML_FILE=$1
  #paaguti: The scenario and the wallpaper are in the same directory
  local WALLPAPER=${XML_FILE%.xml}.pdf

  # ptoribi: list of indexes for reading containers (one scenario may contain several containers, one container may contain several interfaces, one interface may contain several default IPs)
  local CONTAINER_INDEX=1
  local CONTAINER_INTERFACE_INDEX=1
  local CONTAINER_INTERFACE_DEFAULT_IP_INDEX=1
  # ptoribi: list of indexes for reading networks (one scenario may contain several networks, one network may contain several containers, one container may contain several interfaces (attached to that network), one interface may contain several IPs)
  local NETWORK_INDEX=1
  local NETWORK_CONTAINER_INDEX=1
  local NETWORK_CONTAINER_INTERFACE_INDEX=1
  local NETWORK_CONTAINER_INTERFACE_IP_INDEX=1

  # ptoribi: variables for storing data readen from the XML file
  local CONTAINER                             # Will store attribute @name of a container             [REQUIRED]
  local CONTAINER_hostname                    # Will store attribute @hostname of a container         [OPTIONAL] [DEFAULT=@name]
  local CONTAINER_type                        # Will store attribute @type of a container             [REQUIRED]
  local CONTAINER_INTERFACE                   # Will store attribute @name of an interface            [REQUIRED]
  local CONTAINER_INTERFACE_enable_ipv6       # Will store attribute @enable_ipv6 of an interface     [OPTIONAL] [DEFAULT="yes"]
  local CONTAINER_INTERFACE_link_local_ipv6   # Will store attribute @link_local_ipv6 of an interface [OPTIONAL] [DEFAULT="yes"]
  local CONTAINER_INTERFACE_connected_to_physical_interface   # Will store attribute @connected_to_physical_interface of an interface [OPTIONAL]
  local CONTAINER_INTERFACE_DEFAULT_IP        # Will store the content of a default_ip element        [OPTIONAL]
  local NETWORK                               # Will store attribute @name of a network               [REQUIRED]
  local NETWORK_type                          # Will store attribute @type of a network               [OPTIONAL] [DEFAULT="switch"]
  local NETWORK_CONTAINER                     # Will store attribute @name of a container             [REQUIRED]
  local NETWORK_CONTAINER_INTERFACE           # Will store attribute @name of an interface            [REQUIRED]
  local NETWORK_CONTAINER_INTERFACE_IP        # Will store the content of an ip element               [OPTIONAL]

  local CONTAINER_NAME_ARRAY
  local CONTAINER_TYPE_ARRAY
  local CONTAINER_HOSTNAME_ARRAY

  # ptoribi: first of all, validation. Lightning will not process XML files that do not comply with the Lightning XML Schema.
  xmllint --schema $XSD_FILE $XML_FILE --noout >> $LIGHTNING_GENERAL_LOG_FILE
  if [ $? == 0 ]
  then
    # XML OK
    # paaguti: if local show the scenario if the PDF is available
    if [ $REMOTE -eq 0 ]; then
      [ -e $WALLPAPER ] && evince $WALLPAPER 2>/dev/null &
    fi
    # ptoribi: READ CONTAINERS
    CONTAINER=$(xmllint --xpath 'string(/scenario/container['$CONTAINER_INDEX']/@name)' $XML_FILE)
    while [[ ${#CONTAINER} -ne 0 ]]
    do

      CONTAINER_hostname=$(xmllint --xpath 'string(/scenario/container['$CONTAINER_INDEX']/@hostname)' $XML_FILE)
      if [[ ${#CONTAINER_hostname} -eq 0 ]]; then CONTAINER_hostname=$CONTAINER; fi
      CONTAINER_type=$(xmllint --xpath 'string(/scenario/container['$CONTAINER_INDEX']/@type)' $XML_FILE)
      #echo $'\n'$CONTAINER $(tput setaf 240)\(\"$CONTAINER_hostname\", $CONTAINER_type\)$(tput sgr 0)
      create_container $CONTAINER $CONTAINER_hostname $CONTAINER_type $XML_FILE

      CONTAINER_INTERFACE=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$CONTAINER_INTERFACE_INDEX']/@name)' $XML_FILE)
      while [[ ${#CONTAINER_INTERFACE} -ne 0 ]]
      do
        CONTAINER_INTERFACE_enable_ipv6=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$CONTAINER_INTERFACE_INDEX']/@enable_ipv6)' $XML_FILE)
        # ptoribi: set default value for @enable_ipv6
        if [[ ${#CONTAINER_INTERFACE_enable_ipv6} -eq 0 ]]; then CONTAINER_INTERFACE_enable_ipv6="yes"; fi

        CONTAINER_INTERFACE_link_local_ipv6=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$CONTAINER_INTERFACE_INDEX']/@link_local_ipv6)' $XML_FILE)
        # ptoribi: set default value for @link_local_ipv6
        if [[ ${#CONTAINER_INTERFACE_link_local_ipv6} -eq 0 ]]; then CONTAINER_INTERFACE_link_local_ipv6="yes"; fi

        CONTAINER_INTERFACE_rpath_filter=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$CONTAINER_INTERFACE_INDEX']/@rpath_filter)' $XML_FILE)
        # ptoribi: set default value for @rpath_filter
        if [[ ${#CONTAINER_INTERFACE_rpath_filter} -eq 0 ]]; then CONTAINER_INTERFACE_rpath_filter="no"; fi

        CONTAINER_INTERFACE_connected_to_physical_interface=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$CONTAINER_INTERFACE_INDEX']/@connected_to_physical_interface)' $XML_FILE)
        if [[ ${#CONTAINER_INTERFACE_connected_to_physical_interface} -ne 0 ]]
        then
          connect_machine_physical $CONTAINER $CONTAINER_INTERFACE $CONTAINER_INTERFACE_connected_to_physical_interface
        else
          create_interface $CONTAINER $CONTAINER_INTERFACE
        fi

        if [ $CONTAINER_INTERFACE_enable_ipv6 == "no" ]
        then
          disable_ipv6 $CONTAINER $CONTAINER_INTERFACE
        fi

        if [ $CONTAINER_INTERFACE_enable_ipv6 == "yes" ] && [ $CONTAINER_INTERFACE_link_local_ipv6 == "no" ]
        then
          # ptoribi: clears the default link-local IPv6 by removing all the IPs from the interface
          clear_interface $CONTAINER $CONTAINER_INTERFACE
        fi
        #echo "  "$CONTAINER_INTERFACE $(tput setaf 240)\(enable_ipv6=\"$CONTAINER_INTERFACE_enable_ipv6\", link_local_ipv6=\"$CONTAINER_INTERFACE_link_local_ipv6\"\)$(tput sgr 0)

        # enable reverse path filter
        if [ $CONTAINER_INTERFACE_rpath_filter == "yes" ]
        then
          set_rp_filter $CONTAINER $CONTAINER_INTERFACE 1
        else
          set_rp_filter $CONTAINER $CONTAINER_INTERFACE 0
        fi

        CONTAINER_INTERFACE_DEFAULT_IP=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface[./@name="'"$CONTAINER_INTERFACE"'"]/default_ip['$CONTAINER_INTERFACE_DEFAULT_IP_INDEX'])' $XML_FILE)
        while [[ ${#CONTAINER_INTERFACE_DEFAULT_IP} -ne 0 ]]
        do
          #echo "    "$CONTAINER_INTERFACE_DEFAULT_IP
          configure_ip $CONTAINER $CONTAINER_INTERFACE $CONTAINER_INTERFACE_DEFAULT_IP

          ((CONTAINER_INTERFACE_DEFAULT_IP_INDEX++))
          CONTAINER_INTERFACE_DEFAULT_IP=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface[./@name="'"$CONTAINER_INTERFACE"'"]/default_ip['$CONTAINER_INTERFACE_DEFAULT_IP_INDEX'])' $XML_FILE)
        done
        CONTAINER_INTERFACE_DEFAULT_IP_INDEX=1
        ((CONTAINER_INTERFACE_INDEX++))
        CONTAINER_INTERFACE=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$CONTAINER_INTERFACE_INDEX']/@name)' $XML_FILE)
      done
      CONTAINER_INTERFACE_INDEX=1

      # ptoribi: I populate these three arrays with the name of the container, its type and hostname,
      # the purpose of this is to store the info about the containers in order to display the
      # xterm window only after all they have been properly initialized and connected
      CONTAINER_NAME_ARRAY[$CONTAINER_INDEX]=$CONTAINER
      CONTAINER_TYPE_ARRAY[$CONTAINER_INDEX]=$CONTAINER_type
      CONTAINER_HOSTNAME_ARRAY[$CONTAINER_INDEX]=$CONTAINER_hostname

      ((CONTAINER_INDEX++))
      CONTAINER=$(xmllint --xpath 'string(/scenario/container['$CONTAINER_INDEX']/@name)' $XML_FILE)
    done
    CONTAINER_INDEX=1


    # ptoribi: READ NETWORKS
    NETWORK=$(xmllint --xpath 'string(/scenario/network['$NETWORK_INDEX']/@name)' $XML_FILE)
    while [[ ${#NETWORK} -ne 0 ]]
    do
      NETWORK_type=$(xmllint --xpath 'string(/scenario/network['$NETWORK_INDEX']/@type)' $XML_FILE)
      if [[ ${#NETWORK_type} -eq 0 ]]; then NETWORK_type="switch"; fi
      #echo $'\n'$NETWORK $(tput setaf 24)\($NETWORK_type\)$(tput sgr 0)
      create_network $NETWORK $NETWORK_type

      NETWORK_CONTAINER=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container['$NETWORK_CONTAINER_INDEX']/@name)' $XML_FILE)
      while [[ ${#NETWORK_CONTAINER} -ne 0 ]]
      do
        #echo "  "$NETWORK_CONTAINER

        NETWORK_CONTAINER_INTERFACE=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface['$NETWORK_CONTAINER_INTERFACE_INDEX']/@name)' $XML_FILE)
        while [[ ${#NETWORK_CONTAINER_INTERFACE} -ne 0 ]]
        do
          #echo "    "$NETWORK_CONTAINER_INTERFACE
          connect_machine $NETWORK_CONTAINER $NETWORK_CONTAINER_INTERFACE $NETWORK

          NETWORK_CONTAINER_INTERFACE_IP=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface[./@name="'"$NETWORK_CONTAINER_INTERFACE"'"]/ip['$NETWORK_CONTAINER_INTERFACE_IP_INDEX'])' $XML_FILE)
          while [[ ${#NETWORK_CONTAINER_INTERFACE_IP} -ne 0 ]]
          do
            #echo "      "$NETWORK_CONTAINER_INTERFACE_IP
            configure_ip $NETWORK_CONTAINER $NETWORK_CONTAINER_INTERFACE $NETWORK_CONTAINER_INTERFACE_IP

            ((NETWORK_CONTAINER_INTERFACE_IP_INDEX++))
            NETWORK_CONTAINER_INTERFACE_IP=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface[./@name="'"$NETWORK_CONTAINER_INTERFACE"'"]/ip['$NETWORK_CONTAINER_INTERFACE_IP_INDEX'])' $XML_FILE)
          done
          NETWORK_CONTAINER_INTERFACE_IP_INDEX=1
          ((NETWORK_CONTAINER_INTERFACE_INDEX++))
          NETWORK_CONTAINER_INTERFACE=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface['$NETWORK_CONTAINER_INTERFACE_INDEX']/@name)' $XML_FILE)
        done
        NETWORK_CONTAINER_INTERFACE_INDEX=1
        ((NETWORK_CONTAINER_INDEX++))
        NETWORK_CONTAINER=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container['$NETWORK_CONTAINER_INDEX']/@name)' $XML_FILE)
      done
      NETWORK_CONTAINER_INDEX=1
      ((NETWORK_INDEX++))
      NETWORK=$(xmllint --xpath 'string(/scenario/network['$NETWORK_INDEX']/@name)' $XML_FILE)
    done
    NETWORK_INDEX=1

    # ptoribi: allow FORWARDING in ipsec (necessary for IPv6 forwarding in routers), source: https://docs.docker.com/network/iptables/
    iptables -I DOCKER-USER -j ACCEPT

    # ptoribi: display the xterm window of all containers
    for index in "${!CONTAINER_NAME_ARRAY[@]}"
    do
      if [ ${CONTAINER_TYPE_ARRAY[index]} == "host" ]
      then
        display_host ${CONTAINER_NAME_ARRAY[index]} ${CONTAINER_HOSTNAME_ARRAY[index]}
      fi

      if [ ${CONTAINER_TYPE_ARRAY[index]} == "router" ]
      then
        display_router ${CONTAINER_NAME_ARRAY[index]} ${CONTAINER_HOSTNAME_ARRAY[index]}
      fi
    done
    #
    # paaguti: create the description and make files accessible to user
    #
    if [ $REMOTE -eq 1 ]; then
      $LIGHTNING_INSTALLATION_PATH/scenario2txt $XML_FILE > $USER_BEHIND_SUDO_HOME_PATH/description.txt
      chown $USER:$USER $USER_BEHIND_SUDO_HOME_PATH/commands
      chown $USER:$USER $USER_BEHIND_SUDO_HOME_PATH/description.txt
    fi
    success_message "Scenario successfully launched"

  else
    error_message "$XML_FILE validation error, the file does not comply with the Lightning XML Schema"
  fi
}

#paaguti: look for file $1 in the local scenarios and the global scenarios
#         print if found
#        "$(get_scenario_fullname <file>)" is an empty string if not found!
function get_scenario_fullname()
{
  local XML_FILE=$1

  for d in $SCENARIOS_PATH_LOCAL $SCENARIOS_PATH
  do
    [ -e $d/$XML_FILE ] && echo "$d/$XML_FILE"
  done
}
